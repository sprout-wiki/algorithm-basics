## 말로 요약

큰 놈(버블)을 오른쪽으로 계속 밀어냄

## 손으로 해보기

입력

[5,8,4,2]

i=0

5,8 비교 - no swap [5,8,4,2]

8,4 비교 - swap [5,4,8,2]

8,2 비교 - swap [5,4,2,8]

맨 끝자리인 8 은 최댓값으로 확정됨. [5,4,2,*]

- [a,M,c,d] 를 가정했을때 M은 반드시 끝으로 이동함

i=1

5,4 비교 - swap [4,5,2,*]

5,2 비교 - swap [4,2,5,*]

5는 두번째로 큰 값임이 확정됨 [4,2,*,*]

i=2

4,2 비교 - swap [2,4,*,*]

4는 세번째로 큰 값임이 확정됨 [2,*,*,*]

2는 자동으로 가장 작은값임이 확정됨 [*,*,*,*]

정렬 완료

# 성능평가
### 평균 시간복잡도 O(n^2)
- 총 n-1 회 패스를 돌고,
- 각 패스에서 최대 n-1 비교 및 교환
- n*n = O(n^2)

### 최악 시간복잡도 O(n^2)
- 최악경우 : 배열이 내림차순 정렬
- 비교할때마다 반드시 swap 발생 - n번 swap
- n*n = O(n^2)

### 제자리 정렬(In-place Sort)
- 추가 메모리 1개 사용 (tmp). O(1) 메모리를 사용하므로 제자리성 알고리즘

### 안정 정렬(Stable Sort)
- 동일한 값이 있으면 swap 하지 않음!
- 동일한 값의 주소값이 유지됨!